# OpenGL - 创建三角形

**学习要点：**

1. 顶点数组对象：Vertex Array Object，VAO
2. 顶点缓冲对象：Vertex Array Object，VBO
3. 元素缓冲对象：Element Buffer Object，EBO
4. 索引缓冲对象：Index Buffer Object，IBO

> 0. 简介
> 1. 顶点输入
> 2. 顶点着色器
> 3. 编译着色器
> 4. 片段着色器
> 5. 着色器程序
> 6. 链接顶点属性
> 7. 顶点数组对象
> 8. 绘制三角形
> 9. 绘制三角形完整代码 
> 10. 元素缓冲对象
> 11. 绘制矩形完整代码
> 12. 其他资源
> 13. 练习案例



## 0. 简介

在 OpenGL 中，任何事物都在 3D 空间中，而屏幕和窗口却是 2D 像素数组，这导致 OpenGL 的大部分工作都是关于把 3D 坐标转变为适应你屏幕的 2D 像素。3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的 **图形渲染管线**（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。

图形渲染管线可以被划分为两个主要部分：

- 第一部分把你的3D坐标转换为2D坐标

- 第二部分是把2D坐标转变为实际的有颜色的像素

> 2D 坐标和像素也是不同的，2D 坐标精确表示一个点在 2D 空间中的位置，而 2D 像素是这个点的近似值，2D 像素受到你的屏幕/窗口分辨率的限制。

图形渲染管线接受一组 3D 坐标，然后把它们转变为你屏幕上的有色 2D 像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在 GPU 上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做 **着色器**(Shader)。

有些着色器可以由开发者配置，因为允许用自己写的着色器来代替默认的，所以能够更细致地控制图形渲染管线中的特定部分了。因为它们运行在 GPU 上，所以节省了宝贵的 CPU 时间。OpenGL 着色器是用**OpenGL着色器语言(**OpenGL Shading Language, GLSL)写成的。

**图形渲染的每个阶段的抽象展示：**

![img](03.OpenGL%20-%20%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2.assets/pipeline.png)

图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。

1. **顶点着色器（Vertex Shader）：**

   它把一个单独的顶点作为输入。顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。

2. **形状（图元）装配（Primitive Assmbly）：**

   将顶点着色器输出的所有顶点作为输入（如果是 GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状。

3. **几何着色器（Deometry Shader）：**

   几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。

4. **光栅化阶段（Rasteriztion Stage）：**

   会把图元映射为最终屏幕上相应的像素，生成供 **片段着色器**(Fragment Shader)使用的**片段**(Fragment)。在片段着色器运行之前会执行**裁切**(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。

   > OpenGL 中的一个片段是 OpenGL 渲染一个像素所需的所有数据。

5. **片段着色器（Fragment Shader）：**

   主要目的是计算一个像素的最终颜色，这也是所有 OpenGL 高级效果产生的地方。通常，片段着色器包含 3D 场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。

6. **测试和混合（Alpha 测试 和 混合（Blending））:**

   个阶段检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查 alpha 值（alpha 值定义了一个物体的透明度）并对物体进行混合( Blend )。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。

> 现代 OpenGL 中，必须至少定义一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。



## 1. 顶点输入

**OpenGL 是一个 3D 图形库，所以在 OpenGL 中我们指定的所有坐标都是 3D 坐标（x、y和z）。**

OpenGL 不是简单地把**所有的 **3D 坐标变换为屏幕上的 2D 像素；OpenGL 仅当 3D 坐标在 3 个轴（x、y和z）上 -1.0 到 1.0 的范围内时才处理它。所有在这个范围内的坐标叫做标准化设备坐标（Normalized Device Coordinates），此范围内的坐标最终显示在屏幕上（在这个范围以外的坐标则不会显示）。

当渲染一个三角形时，我们一共要指定三个顶点，每个顶点都有一个 3D 位置。

将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个`float`数组：

~~~c++
float positions[] = {
    -0.5f, -0.5f, 0.0f,
     0.5f, -0.5f, 0.0f,
     0.0f,  0.5f, 0.0f
};
~~~

由于 OpenGL 是在 3D 空间中工作的，而我们渲染的是一个 2D 三角形，所以将顶点 z 坐标设置为 0.0。这样子的话三角形每一点的*深度*（Depth）都是一样的，从而使它看上去像是 2D 的。

> 通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。

**标准化设备坐标（Normalized Device Coordinates，NDC）：**

一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是**标准化设备坐标**了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)：

![img](03.OpenGL%20-%20%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2.assets/ndc.png)

与通常的屏幕坐标不同，y轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。

> 通过使用由 `glViewport` 函数提供的数据，进行**视口变化（Viewport Transform）**，标准化设备坐标（Normalized Device Coordinates） 会变换为 **屏幕空间坐标（Screen-space Coordinates）**。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。

定义这样的顶点数据以后，会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在 GPU 上创建内存用于储存我们的顶点数据，还要配置 OpenGL 如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。

通过 **顶点缓冲对象（Vertex Buffer Objects，VBO）**管理这部分内存，它会在 GPU 内存中存储大量顶点。用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从 CPU 把数据发送到显卡相对较慢，所以只要能都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。

顶点缓冲对象拥有一个独一无二的 ID，通过使用 `glGenBuffers` 函数和一个缓冲 ID 生成一个 VBO 对象：

~~~c++
// 定义顶点缓冲对象
unsigned int VBO;
// 使用顶点缓冲函数
glGenBuffers(1, &VBO);
~~~

OpenGL 有很多缓冲对象类型，顶点缓冲对象的缓冲类型是`GL_ARRAY_BUFFER`。OpenGL 允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用 `glBindBuffer`函数把新创建的缓冲绑定到 `GL_ARRAY_BUFFER` 目标上：

~~~c++
// 绑定顶点缓冲对象
glBindBuffer(GL_ARRAY_BUFFER, VBO);
~~~

从这一刻起，使用的任何（在 `GL_ARRAY_BUFFER` 目标上）缓冲调用会用来配置当前绑定缓冲（buffer）。

然后通过调用 `glBufferData` 函数将之前定义的i的那个点数据复制到缓冲的内存中：

~~~c++
// 顶点数据传入
glBufferData(GL_ARRAY_BUFFER, 9 * sizeof(float), positions, GL_STATIC_DRAW);
~~~

`glBufferData` 函数一个专门将用户定义的数据复制到当前绑定缓冲的函数。

- 第一个参数：目标缓冲的类型：顶点缓冲对象当前绑定到 `GL_ARRAY_BUFFER` 目标上。

- 第二个参数：指定传输数据的大小（字节单位）；可以通过 `sizeof` 计算大小。

- 第三个参数：实际顶点数据位置。

- 第四个参数：指定显卡如何管理给定数据，有三种形式：

  1. `GL_STATIC_DRAW`：数据不会或几乎不会改变。
  2. `GL_DYNAMIC_DRAW`：数据会被改变很多。
  3. `GL_STREAM_DRAW`：数据每次绘制时都会改变。

  三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是 `GL_STATIC_DRAW`。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是 `GL_DYNAMIC_DRAW` 或 `GL_STREAM_DRAW`，这样就能确保显卡把数据放在能够高速写入的内存部分。



## 2. 顶点着色器

**顶点着色器（Vertex Shader）：** 使用着色器语言 GLSL（OpenGL Shading Language）编写顶点着色器。

~~~c
#version 330 core
layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
~~~

> 可以看到，GLSL 看起来很像 C 语言。每个着色器都起始于一个版本声明。OpenGL 3.3 以及和更高版本中，GLSL 版本号和 OpenGL 的版本是匹配的（比如说 GLSL 420 版本对应于OpenGL 4.2）。我们同样明确表示我们会使用核心模式。

`in` 关键字。在顶点着色器中声明所有的输入顶点属性（Input Vertex Attribute）。

现在使用的是位置（position）数据，所以只需要一个顶点属性。GLSL 有一个向量数据类型，它包含 1 到 4 个 `float` 分量，包含的数量可以从它的后缀数字看出来。

由于每个顶点都有一个 3D 坐标，所以创建一个 `vec3` 输入变量 aPos。同样也通过 `layout (location = 0)` 设定了输入变量的位置值（Location）。

> **向量（Vector）：**
>
> 在图形编程中我们经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在 GLSL 中一个向量有最多 4 个分量，每个分量值都代表空间中的一个坐标，它们可以通过 `vec.x`、`vec.y`、`vec.z `和 `vec.w` 来获取。注意`vec.w`分量不是用作表达空间中的位置的（处理的是 3D 不是 4D），而是用在所谓透视除法（Perspective Division）上。

设置顶点着色器的输出，必须把位置数据赋值给预定义的 `gl_Position` 变量，它在幕后是 `vec4` 类型。

在 main 函数的最后，将 `gl_Position` 设置的值会成为该顶点着色器的输出。由于我们的输入是一个 3 分量的向量，我们必须把它转换为4分量的。我们可以把 `vec3` 的数据作为 `vec4` 构造器的参数，同时把 `w` 分量设置为 `1.0f`  来完成这一任务。



## 3. 编译着色器

将顶点着色器的源代码硬编码在代码文件顶部的 C 风格字符串中：

~~~c++
// 顶点着色器 C 风格
const char* vertexShaderSource = "#Version 460 cire\n"
	"layout (location = 0) in vec3 aPos;\n"
	"void main()\n"
	"{\n"
	"	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
	"}\0";
~~~

为了能够 OpenGL 使用，需要在运行时动态编译它的源代码。

首先，创建一个着色器对象，注意还是用 ID来引用。所以存储这个顶点着色器为：`unsigned int` ，通过 `glCreateShader` 创建着色器：

~~~c++
// 创建顶点着色器 ID
unsigned int vertexShader;
// 创建顶点着色器
vertexShader = glCreateShader(GL_VERTEX_ARRAY);
~~~

把需要创建的着色器类型以参数形式提供给 `glCreateShader`。由于我们正在创建一个顶点着色器，传递的参数是 `GL_VERTEX_SHADER`。

下一步，将着色器源码附加到着色器对象上，然后编译：

~~~c++
// 将着色器源码附加到着色器上
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
// 附加后进行编译
glCompileShader(vertexShader);
~~~

`glShaderSource` 函数：

- 第一个参数：着色器对象。
- 第二个参数：指定传递的源码字符数量。
- 第三个参数：顶点着色器源码。
- 第四个参数：先设置为 NULL。

> 检测编译时错误代码：
>
> ~~~c++
> // 检测顶点着色器是否成功编译完成
> int success;
> char infoLog[512];
> glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
> ~~~
>
> 定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用 `glGetShaderiv` 检查是否编译成功。如果编译失败，我们会用 `glGetShaderInfoLog` 获取错误消息，然后打印它：
>
> ~~~c++
> // 判断
> if (!success)
> {
> 	// 写入错误报告
> 	glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
> 	cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << endl;
> }
> ~~~



## 4. 片段着色器

片段着色器（Fragment Shader）是第二个也是最后一个我们打算创建的用于渲染三角形的着色器。

> 在计算机图形中颜色被表示为有 4 个元素的数组：红色、绿色、蓝色和 alpha (透明度)分量，通常缩写为 RGBA。当在 OpenGL 或 GLSL 中定义一个颜色的时候，我们把颜色每个分量的强度设置在 0.0 到 1.0 之间。比如说我们设置红为 1.0f，绿为 1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过 1600 万种不同的颜色！

~~~c
#version 330 core
out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
} 
~~~

片段着色器只需要一个输出变量，这个变量是一个 4 分量向量，它表示的是最终的输出颜色，应自己将其计算出来。声明输出变量可以使用 `out` 关键字，这里我们命名为 FragColor。下面，我们将一个 Alpha 值为 1.0(1.0代表完全不透明)的橘黄色的 `vec4` 赋值给颜色输出。

编译片段着色器的过程与顶点着色器类似，使用 `GL_FRAGMENT_SHADER` 常量作为着色器类型：

~~~c++
// 创建片段着色器 ID
unsigned int fragmentShader;
// 创建片段着色器
fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
// 将片段着色器源码附加到片段着色器上
glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
// 编译
glCompileShader(fragmentShader);
~~~



## 5. 着色器程序

着色器程序（Shader Program Object）多个着色器合并之后并最终链接完成的版本。

如果要使用刚才编译的着色器我们必须把它们链接（Link）为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。

当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。

创建一个简单的程序对象：

~~~c++
// 三、创建着色器程序对象
unsigned int shaderProgram;
// 创建
shaderProgram = glCreateProgram();
~~~

`glCreateProgram` 函数创建一个程序，并返回新创建程序对象的 ID 引用。

现在将之前编译的着色器附加到程序对象上，然后用 `glLinkProgram` 链接起来：

~~~c++
// 将顶点着色器和片段着色器附加到程序对象上
glAttachShader(shaderProgram, vertexShader);
glAttachShader(shaderProgram, fragmentShader);
// 顶点和片段链接
glLinkProgram(shaderProgram);
~~~

> 检测链接是否成功：
>
> ~~~c++
> // 判断着色器程序是否成功
> glGetShaderiv(shaderProgram, GL_LINK_STATUS, &success);
> // 判断
> if (!success)
> {
> 	// 写入错误报告
> 	glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
> 	cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << endl;
> }
> ~~~

得到的结果就是一个程序对象，调用 `glUseProgram` 函数，用刚创建的程序对象作为它的参数，以激活这个程序对象（while 循环中进行激活）：

~~~c++
// 激活程序对象
glUseProgram(shaderProgram);
~~~

在 `glUseProgram` 函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。

在把着色器对象链接到程序对象以后，记得删除着色器对象：

~~~c++
// 删除顶点和片段
glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);
~~~

现在，已经把输入顶点数据发送给了 GPU，并指示了 GPU 如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，OpenGL 还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。



## 6. 链接顶点属性

顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。         

![img](03.OpenGL%20-%20%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2.assets/vertex_attribute_pointer.png)

- 位置数据被存储为 32 位（4 字节）浮点值。
- 每个位置包含 3 个值。
- 在这3个值之间没有空隙（或其他值）。这几个值在数组中紧**密排列（Tightly Packed）**。
- 数据中第一个值在缓冲开始的位置。

这些信息通过使用 `glVertexAttribPointer` 函数告诉 OpenGL 如何解析顶点数据（应用到诸葛顶点属性上）：

~~~c++
// 五、解析顶点数据
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
~~~

`glVertexAttribPointer` 函数参数解析：

- 第一个参数：指定配置顶点属性。

  在顶点着色器中使用了 `layout(location = 0)` 定义了 position 顶点属性位置值（Location），它将顶点属性的位置设置为了 0。所以，这里传入一个 0。

- 第二个参数：指定顶点属性大小。

  顶点属性是一个 `vec3` ，它由 3 个值组成，所以大小为：3。

- 第三个参数：指定数据类型。

  这里是 GL_FLOAT（ GLSL 中 `vec* `都是由浮点数值组成的）。

- 第四个参数：是否希望数据被标准化（Normalize）。

  如果设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。

- 第五个参数：步长（Stride）。

  告诉在连续的顶点属性组之间的间隔。由于下个组的位置数据在3个 float 之后，所以设置步长位：`3 * sizeof(float)` 。

- 第六个参数：位置数据在缓冲中起始位置的偏移量（Offset）。

  由于位置数据在数组的开头，所以这里是0。

> 每一个顶点属性从一个 VBO 管理的内存中获取得到它的数据，而具体是从哪个 VBO（程序中可以有多个 VBO）获取则通过调用 `glVertexAttribPoiner` 时绑定 GL_ARRAY_BUFFER 的 VBO 决定的。由于在调用 `glVertexAttribPointer` 之前绑定的是先前定义的 VBO 对象，顶点属性 `0` 现在会链接到它的顶点数据。

接下来通过使用 `glEnableVertexAttribArray` 函数，一顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。

然后使用顶点缓冲对象将顶点数据初始化至缓冲中，建立一个顶点和一个片段着色器，并告诉了OpenGL如何把顶点数据链接到顶点着色器的顶点属性上：

~~~c++
// 0. 复制顶点数组到缓冲中供OpenGL使用
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 1. 设置顶点属性指针
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
// 2. 当我们渲染一个物体时要使用着色器程序
glUseProgram(shaderProgram);
// 3. 绘制物体
someOpenGLFunctionThatDrawsOurTriangle();
~~~

每当绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过5个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。



## 7. 顶点数组对象

**顶点数组对象（Vertex Array Object，VAO）**：可以像顶点缓冲对象那样被绑定，任何随后的顶带你属性调用都会储存在 VAO 中。

这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的 VAO 就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的 VAO 就行了。刚刚设置的所有状态都将存储在 VAO 中

> OpenGL 的核心模式 **要求** 使用 VAO，所以它知道该如何处理我们的顶点输入。如果绑定 VAO 失败，OpenGL 会拒绝绘制任何东西。

一个顶点数组对象会储存以下这些内容：

- `glEnableVertexAttribArray` 和 `glDisableVertexAttribArray ` 的调用。
- 通过 `glVertexAttribPointer` 设置的顶点属性配置。
- 通过 `glVertexAttribPointer` 调用与顶点属性关联的顶点缓冲对象。

![img](03.OpenGL%20-%20%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2.assets/vertex_array_objects.png)

创建一个 VAO 和创建一个 VBO 很类似：

~~~c++
// 定义顶点数组对象
unsigned int VBO, VAO;
glGenVertexArrays(1, &VAO);
~~~

想要使用则需要用到 `glBindVertexArray` 函数绑定 VAO。

从绑定之后起，应该绑定和配置对应的VBO和属性指针，之后解绑 VAO 供之后使用。当绘制一个物体的时候，只要在绘制物体前简单地把 VAO 绑定到希望使用的设定上就行了。这段代码应该看起来像这样：

~~~c++
glBindVertexArray(VAO);
// 绘制物体
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
~~~

前面做的一切都是等待这一刻，一个储存了我们顶点属性配置和应使用的 VBO 的顶点数组对象。

一般当你打算绘制多个物体时，首先要生成/配置所有的 VAO（和必须的 VBO 及属性指针)，然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的 VAO，绑定它，绘制完物体后，再解绑 VAO。

## 8. 绘制三角形

OpenGL 提供了 `glDrawArrays` 函数，使用当前激活的着色器，之前定义的顶点属性配置，和 VBO 的顶点数据（通过 VAO 简介绑定）进行绘制图元。

~~~c++
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
glDrawArrays(GL_TRIANGLES, 0, 3);
~~~

`glDrawArrays` 函数参数：

- 第一个参数：打算绘制的 OpenGL 图元类型。
- 第二个参数：制定了顶点数组起始索引。
- 第三个参数：绘制的顶点数量。

![image-20230330105927970](03.OpenGL%20-%20%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2.assets/image-20230330105927970.png)



## 9. 绘制三角形完整代码 

~~~c++
#define _CRT_SECURE_NO_WARNINGS 1
#include <iostream>
// GL ADdress
// GLAD的头文件包含了正确的OpenGL头文件
#include <glad/glad.h>
// OpenGL 的轻量级工具程序库
// Graphics Library Framework（图形库框架）
#include <GLFW/glfw3.h>
using namespace std;

// 定义函数头声明
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow* window);

// 顶点着色器 C 风格
const char* vertexShaderSource = "#version 330 core\n"
"layout (location = 0) in vec3 aPos;\n"
"void main()\n"
"{\n"
"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
"}\0";
// 片段着色器 C 风格
const char* fragmentShaderSource = "#version 460 core\n"
"out vec4 FragColor;\n"
"void main()\n"
"{\n"
"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
"}\n\0";

int main()
{
	// 1. 初始化GLFW
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	// 确保兼容性
#ifdef __APPLE__
	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

	// 2. 创建窗口指针
	GLFWwindow* window = glfwCreateWindow(800, 800, "Create Triangle", NULL, NULL);
	// 判断是否成功
	if (window == NULL)
	{
		cout << "Failed to create GLFW window" << endl;
		// 释放
		glfwTerminate();
		// 终止
		return -1;
	}

	// 4. 设置自适应窗口
	glfwMakeContextCurrent(window);
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

	// 3. 初始化 GLAD
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return -1;
    }

	// 一、创建顶点着色器 ID
	unsigned int vertexShader;
	// 创建顶点着色器
	vertexShader = glCreateShader(GL_VERTEX_SHADER);
	// 将着色器源码附加到着色器上
	glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
	// 附加后进行编译
	glCompileShader(vertexShader);
	// 检测顶点着色器是否成功编译完成
	int success;
	char infoLog[512];
	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
	// 判断
	if (!success)
	{
		// 写入错误报告
		glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
		cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << endl;
	}

	// 二、创建片段着色器 ID
	unsigned int fragmentShader;
	// 创建片段着色器
	fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
	// 将片段着色器源码附加到片段着色器上
	glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
	// 编译
	glCompileShader(fragmentShader);
	// 检查编译受否成功
	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
	// 判断
	if (!success)
	{
		// 写入错误报告
		glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
		cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << endl;
	}

	// 三、创建着色器程序对象
	unsigned int shaderProgram;
	// 创建
	shaderProgram = glCreateProgram();
	// 将顶点着色器和片段着色器附加到程序对象上
	glAttachShader(shaderProgram, vertexShader);
	glAttachShader(shaderProgram, fragmentShader);
	// 顶点和片段链接
	glLinkProgram(shaderProgram);
	// 判断着色器程序是否成功
	glGetShaderiv(shaderProgram, GL_LINK_STATUS, &success);
	// 判断
	if (!success)
	{
		// 写入错误报告
		glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
		cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << endl;
	}

	// 四、删除顶点和片段
	glDeleteShader(vertexShader);
	glDeleteShader(fragmentShader);

	// 定义三角形的三个三维顶点
	float positions[] = {
		-0.5f, -0.5f, 0.0f,
		 0.5f, -0.5f, 0.0f,
		 0.0f,  0.5f, 0.0f
	};

	// 定义顶点缓冲、数组对象
	unsigned int VBO, VAO;
	// 使用顶点缓冲、数组函数
	glGenVertexArrays(1, &VAO);
	glGenBuffers(1, &VBO);
	// 绑定顶点缓冲、数组对象
	glBindVertexArray(VAO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	// 顶点数据传入
	glBufferData(GL_ARRAY_BUFFER, 9 * sizeof(float), positions, GL_STATIC_DRAW);

	// 五、解析顶点数据 -  设置顶点属性指针
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	glEnableVertexAttribArray(0);

	// 5. 循环渲染窗口
	while (!glfwWindowShouldClose(window))
	{
		// input 输入获取
	    // -----
		processInput(window);

		// render 渲染部分
		// ...
		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT);

		// 激活程序对象
		glUseProgram(shaderProgram);
		glBindVertexArray(VAO);
		// OpenGL 自带API
		glDrawArrays(GL_TRIANGLES, 0, 3);

		// 状态缓冲
		glfwSwapBuffers(window);
		// 更新事件
		glfwPollEvents();
	}

	return 0;
}

// 定义窗口大小函数封装
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	// 设置视口大小
	glViewport(0, 0, width, height);
}

// 定义获取输入函数封装
void processInput(GLFWwindow* window)
{
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
		glfwSetWindowShouldClose(window, true);
}
~~~



## 10. 元素缓冲对象

**元素缓冲对象（Element Buffer Object，EBO）**：也叫做 **索引缓冲对象（Index Buffer Object，IBO）**。

假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。这会生成下面的顶点的集合：

~~~c++
float vertices[] = {
    // 第一个三角形
    0.5f, 0.5f, 0.0f,   // 右上角
    0.5f, -0.5f, 0.0f,  // 右下角
    -0.5f, 0.5f, 0.0f,  // 左上角
    // 第二个三角形
    0.5f, -0.5f, 0.0f,  // 右下角
    -0.5f, -0.5f, 0.0f, // 左下角
    -0.5f, 0.5f, 0.0f   // 左上角
};
~~~

可以看到，有几个顶点叠加了。我们指定了 `右下角` 和 `左上角` 两次！一个矩形只有 4 个而不是 6 个顶点，这样就产生 50% 的额外开销。当有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。

更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子只要储存 4 个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。

值得庆幸的是，元素缓冲区对象的工作方式正是如此。 EBO 是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。这种所谓的**索引绘制（Indexed Drawing）** 正是解决方案。

首先，定义（不重复的）顶点，和绘制出矩形所需的索引：

~~~c++
float vertices[] = {
    0.5f, 0.5f, 0.0f,   // 右上角
    0.5f, -0.5f, 0.0f,  // 右下角
    -0.5f, -0.5f, 0.0f, // 左下角
    -0.5f, 0.5f, 0.0f   // 左上角
};

unsigned int indices[] = {
    // 注意索引从0开始! 
    // 此例的索引(0,1,2,3)就是顶点数组vertices的下标，
    // 这样可以由下标代表顶点组合成矩形

    0, 1, 3, // 第一个三角形
    1, 2, 3  // 第二个三角形
};
~~~

当使用索引以后，我们只定义了 4 个顶点，而不是 6 个。

然后，继续创建元素缓冲对象：

~~~c++
unsigned int EBO;
glGenBuffers(1, &EBO);
~~~

与 VBO 类似，我们先绑定 EBO 然后用 `glBufferData` 把索引复制到缓冲里。同样，和 VBO 类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为 `GL_ELEMENT_ARRAY_BUFFER`。

~~~c++
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
~~~

传递了 `GL_ELEMENT_ARRAY_BUFFER` 当作缓冲目标。最后一件要做的事是用 `glDrawElements` 来替换 `glDrawArrays` 函数，表示要从索引缓冲区渲染三角形。使用 `glDrawElements` 时，使用当前绑定的索引缓冲对象中的索引进行绘制：

~~~c++
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
...
// render 渲染部分
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
~~~

`glDrawElements` 函数参数：

- 第一个参数：指定了绘制的模式，
- 第二个参数：绘制顶点个数。
- 第三个参数：索引类型。
- 第四个参数：指定 EBO 中的偏移量。（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候）

`glDrawElements` 函数从当前绑定到 `GL_ELEMENT_ARRAY_BUFFER` 目标的 EBO 中获取其索引。这意味着每次想要使用索引渲染对象时都必须绑定相应的 EBO，这又有点麻烦。碰巧顶点数组对象也跟踪元素缓冲区对象绑定。在绑定 VAO 时，绑定的最后一个元素缓冲区对象存储为 VAO 的元素缓冲区对象。然后，绑定到 VAO 也会自动绑定该 EBO。

![img](03.OpenGL%20-%20%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2.assets/vertex_array_objects_ebo.png)

> 当目标是 `GL_ELEMENT_ARRAY_BUFFER` 的时候，VAO 会储存 `glBindBuffer` 的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑 VAO 之前解绑索引数组缓冲，否则它就没有这个 EBO 配置了。

![image-20230330123615057](03.OpenGL%20-%20%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2.assets/image-20230330123615057.png)

> **线框模式(Wireframe Mode)**
>
> 要想用线框模式绘制你的三角形，你可以通过 `glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)` 函数配置 OpenGL 如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用 `glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)` 将其设置回默认模式。

![image-20230330123800715](03.OpenGL%20-%20%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2.assets/image-20230330123800715.png)



## 11. 绘制矩形完整代码

~~~c++
#define _CRT_SECURE_NO_WARNINGS 1
#include <iostream>
// GL ADdress
// GLAD的头文件包含了正确的OpenGL头文件
#include <glad/glad.h>
// OpenGL 的轻量级工具程序库
// Graphics Library Framework（图形库框架）
#include <GLFW/glfw3.h>
using namespace std;

// 定义函数头声明
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow* window);

// 顶点着色器 C 风格
const char* vertexShaderSource = "#version 330 core\n"
"layout (location = 0) in vec3 aPos;\n"
"void main()\n"
"{\n"
"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
"}\0";
// 片段着色器 C 风格
const char* fragmentShaderSource = "#version 460 core\n"
"out vec4 FragColor;\n"
"void main()\n"
"{\n"
"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
"}\n\0";

int main()
{
	// 1. 初始化GLFW
	glfwInit();
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	// 确保兼容性
#ifdef __APPLE__
	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
#endif

	// 2. 创建窗口指针
	GLFWwindow* window = glfwCreateWindow(800, 800, "Create Triangle", NULL, NULL);
	// 判断是否成功
	if (window == NULL)
	{
		cout << "Failed to create GLFW window" << endl;
		// 释放
		glfwTerminate();
		// 终止
		return -1;
	}

	// 4. 设置自适应窗口
	glfwMakeContextCurrent(window);
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

	// 3. 初始化 GLAD
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        std::cout << "Failed to initialize GLAD" << std::endl;
        return -1;
    }

	// 一、创建顶点着色器 ID
	unsigned int vertexShader;
	// 创建顶点着色器
	vertexShader = glCreateShader(GL_VERTEX_SHADER);
	// 将着色器源码附加到着色器上
	glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
	// 附加后进行编译
	glCompileShader(vertexShader);
	// 检测顶点着色器是否成功编译完成
	int success;
	char infoLog[512];
	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
	// 判断
	if (!success)
	{
		// 写入错误报告
		glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
		cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << endl;
	}

	// 二、创建片段着色器 ID
	unsigned int fragmentShader;
	// 创建片段着色器
	fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
	// 将片段着色器源码附加到片段着色器上
	glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
	// 编译
	glCompileShader(fragmentShader);
	// 检查编译受否成功
	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
	// 判断
	if (!success)
	{
		// 写入错误报告
		glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
		cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << endl;
	}

	// 三、创建着色器程序对象
	unsigned int shaderProgram;
	// 创建
	shaderProgram = glCreateProgram();
	// 将顶点着色器和片段着色器附加到程序对象上
	glAttachShader(shaderProgram, vertexShader);
	glAttachShader(shaderProgram, fragmentShader);
	// 顶点和片段链接
	glLinkProgram(shaderProgram);
	// 判断着色器程序是否成功
	glGetShaderiv(shaderProgram, GL_LINK_STATUS, &success);
	// 判断
	if (!success)
	{
		// 写入错误报告
		glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
		cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << endl;
	}

	// 四、删除顶点和片段
	glDeleteShader(vertexShader);
	glDeleteShader(fragmentShader);

	// 通过定义 矩形来展示两个三角形
	float vertices[] = {
	 0.5f,  0.5f, 0.0f,  // 右上角
	 0.5f, -0.5f, 0.0f,  // 右下角
	-0.5f, -0.5f, 0.0f,  // 左下角
	-0.5f,  0.5f, 0.0f   // 左上角
	};
	// 定义三角形索引
	unsigned int indices[] = {
		// 注意索引从0开始! 
		// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，
		// 这样可以由下标代表顶点组合成矩形
		0, 1, 3,  // 第一个三角形
		1, 2, 3   // 第二个三角形
	};

	// 定义元素\顶点缓冲、数组对象
	unsigned int VBO, VAO, EBO;
	// 使用元素\顶点缓冲、数组函数
	glGenVertexArrays(1, &VAO);
	glGenBuffers(1, &VBO);
	glGenBuffers(1, &EBO);
	// 绑定元素\顶点缓冲、数组对象
	glBindVertexArray(VAO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
	// 元素\顶点数据传入
	glBufferData(GL_ARRAY_BUFFER, 12 * sizeof(float), vertices, GL_STATIC_DRAW);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

	// 五、解析顶点数据 -  设置顶点属性指针
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
	glEnableVertexAttribArray(0);

	// 设置线框模式展示矩形中的两个三角形
	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

	// 5. 循环渲染窗口
	while (!glfwWindowShouldClose(window))
	{
		// input 输入获取
	    // -----
		processInput(window);

		// render 渲染部分
		// ...
		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT);

		// 激活程序对象
		glUseProgram(shaderProgram);
		glBindVertexArray(VAO);
		// OpenGL 自带API
		//glDrawArrays(GL_TRIANGLES, 0, 3);
		// 矩形
		glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

		// 状态缓冲
		glfwSwapBuffers(window);
		// 更新事件
		glfwPollEvents();
	}

	return 0;
}

// 定义窗口大小函数封装
void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	// 设置视口大小
	glViewport(0, 0, width, height);
}

// 定义获取输入函数封装
void processInput(GLFWwindow* window)
{
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
		glfwSetWindowShouldClose(window, true);
}
~~~



## 12. 其他资源

- [antongerdelan.net/hellotriangle](http://antongerdelan.net/opengl/hellotriangle.html)：Anton Gerdelan的渲染第一个三角形教程。
- [open.gl/drawing](https://open.gl/drawing)：Alexander Overvoorde的渲染第一个三角形教程。
- [antongerdelan.net/vertexbuffers](http://antongerdelan.net/opengl/vertexbuffers.html)：顶点缓冲对象的一些深入探讨。
- [调试](https://learnopengl.com/#!In-Practice/Debugging)：这个教程中涉及到了很多步骤，如果你在哪卡住了，阅读一点调试的教程是非常值得的（只需要阅读到调试输出部分）



## 13. 练习

1. 添加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形：

   ~~~c++
   // 引入相关头文件
   #include <iostream>
   #include <glad/glad.h>
   #include <GLFW/glfw3.h>
   using namespace std;
   
   // 函数头
   void framebuffer_size_callback(GLFWwindow* window, int width, int height);
   void processInput(GLFWwindow* window);
   
   const unsigned int SCR_WIDTH = 800;
   const unsigned int SCR_HEIGHT = 600;
   
   // 定义顶点、片段着色器
   const char* vertexShaderSource = "#version 460 core\n"
   "layout (location = 0) in vec3 aPos;\n"
   "void main()\n"
   "{\n"
   "	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
   "}\0";
   const char* fragmentShaderSource = "#version 460 core\n"
   "out vec4 FragColor;\n"
   "void main()\n"
   "{\n"
   "	FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
   "}\n\0";
   
   
   int main()
   {
   	// 1. 初始化 glfw
   	glfwInit();
   	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
   	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
   	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
   	// 设置 MAC 兼容
   #ifdef _APPLE_
   	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
   #endif // _APPLE_
   	
   	// 2. 设置 窗口
   	GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "Two Triangles", NULL, NULL);
   	// 判断窗口是否成功
   	if (window == NULL)
   	{
   		cout << "Failed to create GLFW window" << endl;
   		// 终止
   		glfwTerminate();
   		return -1;
   	}
   
   	// 3. 窗口的自适应设置
   	glfwMakeContextCurrent(window);
   	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
   
   	// 4. 初始化 GLAD
   	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
   	{
   		cout << "Failed to initialize GLAD" << endl;
   		return -1;
   	}
   
   	// 设置顶点、片段着色器
   	unsigned int vertexShader, fragmentShader;
   	// 创建
   	vertexShader = glCreateShader(GL_VERTEX_SHADER);
   	fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
   	// 源码附加
   	glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
   	glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
   	// 解析
   	glCompileShader(vertexShader);
   	glCompileShader(fragmentShader);
   	// 判断 顶点、片段着色器是否成功
   	int success;
   	char infoLog[512];
   	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
   	if (!success)
   	{
   		// 写入错误报告
   		glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
   		cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << endl;
   	}
   	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
   	if (!success)
   	{
   		// 写入错误报告
   		glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
   		cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << endl;
   	}
   
   	// 创建链接着色器
   	unsigned int shaderProgram;
   	shaderProgram = glCreateProgram();
   	// 附加到程序对象上
   	glAttachShader(shaderProgram, vertexShader);
   	glAttachShader(shaderProgram, fragmentShader);
   	// 链接
   	glLinkProgram(shaderProgram);
   	// 判断
   	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
   	if (!success)
   	{
   		glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
   		cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << endl;
   	}
   
   	// 释放 顶点、片段着色器
   	glDeleteShader(vertexShader);
   	glDeleteShader(fragmentShader);
   
   	// 设置顶点坐标
   	float positions[] = {
   		-0.9f, -0.5f, 0.0f, // 左侧三角形 - 左顶点
   		-0.0f, -0.5f, 0.0f, // 左侧三角形 - 右顶点
   		-0.45f, 0.5f, 0.0f, // 左侧三角形 - 顶点
   		// ----------------
   		 0.0f, -0.5f, 0.0f, // 右侧三角形 - 左顶点
   		 0.9f, -0.5f, 0.0f, // 右侧三角形 - 右顶点
   		 0.45f, 0.5f, 0.0f  // 右侧三角形 - 顶点
   	};
   	// 定义顶点缓冲、数组对象
   	unsigned int VBO, VAO;
   	// 使用
   	glGenVertexArrays(1, &VAO);
   	glGenBuffers(1, &VBO);
   	// 绑定
   	glBindVertexArray(VAO);
   	glBindBuffer(GL_ARRAY_BUFFER, VBO);
   	// 设置数据
   	glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW);
   	// 解析顶点数据 -  设置顶点属性指针
   	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
   	glEnableVertexAttribArray(0);
   
   	// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind
   	glBindBuffer(GL_ARRAY_BUFFER, 0);
   
   	// You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other
   	// VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.
   	glBindVertexArray(0);
   
   	// glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
   
   	// 5. 循环渲染
   	while (!glfwWindowShouldClose(window))
   	{
   		// 输入
   		processInput(window);
   
   		// 渲染 视口
   		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
   		glClear(GL_COLOR_BUFFER_BIT);
   
   		// 绘制
   		glUseProgram(shaderProgram);
   		glBindVertexArray(VAO);
   		glDrawArrays(GL_TRIANGLES, 0, 6);
   
   		// 缓冲、更新
   		glfwSwapBuffers(window);
   		glfwPollEvents();
   	}
   
   	// optional: de-allocate all resources once they've outlived their purpose:
   	// ------------------------------------------------------------------------
   	glDeleteVertexArrays(1, &VAO);
   	glDeleteBuffers(1, &VBO);
   	glDeleteProgram(shaderProgram);
   
   	// 6. 终止运行
   	glfwTerminate();
   
   	return 0;
   }
   
   // 窗口设置
   void framebuffer_size_callback(GLFWwindow* window, int width, int height)
   {
   	// 设置视口
   	glViewport(0, 0, width, height);
   }
   
   // 定义获取输入函数封装
   void processInput(GLFWwindow* window)
   {
   	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
   		glfwSetWindowShouldClose(window, true);
   }
   ~~~

   ![image-20230331110809060](03.OpenGL%20-%20%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2.assets/image-20230331110809060.png)

2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO：

   ~~~c++
   #define _CRT_SECURE_NO_WARNINGS 1
   #include <glad/glad.h>
   #include <GLFW/glfw3.h>
   #include <iostream>
   using namespace std;
   
   // 函数头
   void framebuffer_size_callback(GLFWwindow* window, int width, int height);
   void processInput(GLFWwindow* window);
   
   const unsigned int SCR_WIDTH = 800;
   const unsigned int SCR_HEIGHT = 600;
   
   // 定义顶点、片段着色器
   const char* vertexShaderSource = "#version 460 core\n"
   "layout (location = 0) in vec3 aPos;\n"
   "void main()\n"
   "{\n"
   "	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
   "}\0";
   const char* FragmentShaderSource = "#version 460 core\n"
   "out vec4 FragColor;\n"
   "void main()\n"
   "{\n"
   "	FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
   "}\n\0";
   
   int main()
   {
   	// 1. 初始化
   	glfwInit();
   	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
   	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
   	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
   	// 设置 MAC 兼容
   #ifdef _APPLE_
   	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
   #endif // _APPLE_
   
   	// 2. 创建窗口
   	GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "Use Two Different VAO And VBO", NULL, NULL);
   	if (window == NULL)
   	{
   		cout << "Failed to create GLFW window" << endl;
   		// 终止
   		glfwTerminate();
   		return -1;
   	}
   
   	// 3. 窗口的自适应设置
   	glfwMakeContextCurrent(window);
   	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
   
   	// 4. 初始化 GLAD
   	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
   	{
   		cout << "Failed to initialize GLAD" << endl;
   		return -1;
   	}
   
   	// 顶点和片段着色器 ID
   	unsigned int vertexShader, fragmentShader;
   	// 创建
   	vertexShader = glCreateShader(GL_VERTEX_SHADER);
   	fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
   	// 绑定
   	glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
   	glShaderSource(fragmentShader, 1, &FragmentShaderSource, NULL);
   	// 编译
   	glCompileShader(vertexShader);
   	glCompileShader(fragmentShader);
   	// 判断
   	int success;
   	char infoLog[512];
   	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
   	if (!success)
   	{
   		glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
   		cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << endl;
   	}
   	glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
   	if (!success)
   	{
   		glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
   		cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << endl;
   	}
   
   	// 链接陈程序 ID
   	unsigned int shaderProgram;
   	// 创建
   	shaderProgram = glCreateProgram();
   	// 绑定
   	glAttachShader(shaderProgram, vertexShader);
   	glAttachShader(shaderProgram, fragmentShader);
   	// 链接
   	glLinkProgram(shaderProgram);
   	// 判断
   	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
   	if (!success)
   	{
   		glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
   		cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << endl;
   	}
   
   	// 清理顶点和片段
   	glDeleteShader(vertexShader);
   	glDeleteShader(fragmentShader);
   
   
   	// 设置顶点坐标
   	float firstPositions[] = {
   		-0.9f, -0.5f, 0.0f, // 左侧三角形 - 左顶点
   		-0.0f, -0.5f, 0.0f, // 左侧三角形 - 右顶点
   		-0.45f, 0.5f, 0.0f // 左侧三角形 - 顶点
   	};
   	float secondPositions[] = {
   		0.0f, -0.5f, 0.0f, // 右侧三角形 - 左顶点
   		0.9f, -0.5f, 0.0f, // 右侧三角形 - 右顶点
   		0.45f, 0.5f, 0.0f  // 右侧三角形 - 顶点
   	};
   
   	// 定义缓冲和数组
   	unsigned int VBOs[2], VAOs[2];
   	// 使用
   	glGenBuffers(2, VBOs);
   	glGenVertexArrays(2, VAOs);
   	// 第一个 设置
   	glBindVertexArray(VAOs[0]);
   	glBindBuffer(GL_ARRAY_BUFFER, VBOs[0]);
   	glBufferData(GL_ARRAY_BUFFER, 9 * sizeof(float), firstPositions, GL_STATIC_DRAW);
   	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
   	glEnableVertexAttribArray(0);
   	// 第二个设置
   	glBindVertexArray(VAOs[1]);
   	glBindBuffer(GL_ARRAY_BUFFER, VBOs[1]);
   	glBufferData(GL_ARRAY_BUFFER, 9 * sizeof(float), secondPositions, GL_STATIC_DRAW);
   	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
   	glEnableVertexAttribArray(0);
   
   	// 5. 循环函数
   	while (!glfwWindowShouldClose(window))
   	{
   		// 输入
   		processInput(window);
   
   		// 渲染 视口
   		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
   		glClear(GL_COLOR_BUFFER_BIT);
   
   		// 绘制
   		glUseProgram(shaderProgram);
   		// 第一个
   		glBindVertexArray(VAOs[0]);
   		glDrawArrays(GL_TRIANGLES, 0, 3);
   		// 第二个
   		glBindVertexArray(VAOs[1]);
   		glDrawArrays(GL_TRIANGLES, 0, 3);
   
   		// 缓冲、更新
   		glfwSwapBuffers(window);
   		glfwPollEvents();
   	}
   
   	glDeleteVertexArrays(2, VAOs);
   	glDeleteBuffers(2, VBOs);
   	glDeleteProgram(shaderProgram);
   
   	// 6. 结束
   	glfwTerminate();
   
   	return 0;
   }
   
   // 自适应
   void framebuffer_size_callback(GLFWwindow* window, int width, int height)
   {
   	glViewport(0, 0, width, height);
   }
   // 检擦输入
   void processInput(GLFWwindow* window)
   {
   	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
   		glfwSetWindowShouldClose(window, true);
   }
   ~~~

   ![image-20230403100152724](03.OpenGL%20-%20%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2.assets/image-20230403100152724.png)

3. 创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色：

   ~~~c++
   // 创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；
   // 再次绘制这两个三角形，让其中一个输出为黄色
   
   #define _CRT_SECURE_NO_WARNINGS 1
   #include <glad/glad.h>
   #include <GLFW/glfw3.h>
   #include <iostream>
   using namespace std;
   
   // 函数头
   void framebuffer_size_callback(GLFWwindow* window, int width, int height);
   void processInput(GLFWwindow* window);
   
   const unsigned int SCR_WIDTH = 800;
   const unsigned int SCR_HEIGHT = 600;
   
   // 定义顶点、片段着色器
   const char* vertexShaderSource = "#version 460 core\n"
   "layout (location = 0) in vec3 aPos;\n"
   "void main()\n"
   "{\n"
   "	gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
   "}\0";
   const char* FragmentShader1Source = "#version 460 core\n"
   "out vec4 FragColor;\n"
   "void main()\n"
   "{\n"
   "	FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"
   "}\n\0";
   const char* fragmentShader2Source = "#version 330 core\n"
   "out vec4 FragColor;\n"
   "void main()\n"
   "{\n"
   "   FragColor = vec4(1.0f, 1.0f, 0.0f, 1.0f);\n"
   "}\n\0";
   
   int main()
   {
   	// 1. 初始化
   	glfwInit();
   	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
   	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
   	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
   	// 设置 MAC 兼容
   #ifdef _APPLE_
   	glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
   #endif // _APPLE_
   
   	// 2. 创建窗口
   	GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, "Use Two Different VAO And VBO", NULL, NULL);
   	if (window == NULL)
   	{
   		cout << "Failed to create GLFW window" << endl;
   		// 终止
   		glfwTerminate();
   		return -1;
   	}
   
   	// 3. 窗口的自适应设置
   	glfwMakeContextCurrent(window);
   	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
   
   	// 4. 初始化 GLAD
   	if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
   	{
   		cout << "Failed to initialize GLAD" << endl;
   		return -1;
   	}
   
   	// 顶点和片段着色器 ID
   	unsigned int vertexShader, fragmentShaderOrange, fragmentShaderYellow;
   	// 创建
   	vertexShader = glCreateShader(GL_VERTEX_SHADER);
   	fragmentShaderOrange = glCreateShader(GL_FRAGMENT_SHADER);
   	fragmentShaderYellow = glCreateShader(GL_FRAGMENT_SHADER);
   	// 绑定
   	glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
   	glShaderSource(fragmentShaderOrange, 1, &FragmentShader1Source, NULL);
   	glShaderSource(fragmentShaderYellow, 1, &fragmentShader2Source, NULL);
   	// 编译
   	glCompileShader(vertexShader);
   	glCompileShader(fragmentShaderOrange);
   	glCompileShader(fragmentShaderYellow);
   	// 判断
   	int success;
   	char infoLog[512];
   	glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
   	if (!success)
   	{
   		glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
   		cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << endl;
   	}
   	glGetShaderiv(fragmentShaderOrange, GL_COMPILE_STATUS, &success);
   	if (!success)
   	{
   		glGetShaderInfoLog(fragmentShaderOrange, 512, NULL, infoLog);
   		cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << endl;
   	}
   	glGetShaderiv(fragmentShaderYellow, GL_COMPILE_STATUS, &success);
   	if (!success)
   	{
   		glGetShaderInfoLog(fragmentShaderYellow, 512, NULL, infoLog);
   		cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << endl;
   	}
   
   	// 链接陈程序 ID
   	unsigned int shaderProgramOrange, shaderProgramYellow;
   	// 创建
   	shaderProgramOrange = glCreateProgram();
   	shaderProgramYellow = glCreateProgram();
   	// 绑定
   	glAttachShader(shaderProgramOrange, vertexShader);
   	glAttachShader(shaderProgramOrange, fragmentShaderOrange);
   	glAttachShader(shaderProgramYellow, vertexShader);
   	glAttachShader(shaderProgramYellow, fragmentShaderYellow);
   	// 链接
   	glLinkProgram(shaderProgramOrange);
   	glLinkProgram(shaderProgramYellow);
   	// 判断
   	glGetProgramiv(shaderProgramOrange, GL_LINK_STATUS, &success);
   	if (!success)
   	{
   		glGetProgramInfoLog(shaderProgramOrange, 512, NULL, infoLog);
   		cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << endl;
   	}
   	glGetProgramiv(shaderProgramYellow, GL_LINK_STATUS, &success);
   	if (!success)
   	{
   		glGetProgramInfoLog(shaderProgramYellow, 512, NULL, infoLog);
   		cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << endl;
   	}
   
   	// 清理顶点和片段
   	glDeleteShader(vertexShader);
   	glDeleteShader(fragmentShaderOrange);
   
   
   	// 设置顶点坐标
   	float firstPositions[] = {
   		-0.9f, -0.5f, 0.0f, // 左侧三角形 - 左顶点
   		-0.0f, -0.5f, 0.0f, // 左侧三角形 - 右顶点
   		-0.45f, 0.5f, 0.0f // 左侧三角形 - 顶点
   	};
   	float secondPositions[] = {
   		0.0f, -0.5f, 0.0f, // 右侧三角形 - 左顶点
   		0.9f, -0.5f, 0.0f, // 右侧三角形 - 右顶点
   		0.45f, 0.5f, 0.0f  // 右侧三角形 - 顶点
   	};
   
   	// 定义缓冲和数组
   	unsigned int VBOs[2], VAOs[2];
   	// 使用
   	glGenBuffers(2, VBOs);
   	glGenVertexArrays(2, VAOs);
   	// 第一个 设置
   	glBindVertexArray(VAOs[0]);
   	glBindBuffer(GL_ARRAY_BUFFER, VBOs[0]);
   	glBufferData(GL_ARRAY_BUFFER, 9 * sizeof(float), firstPositions, GL_STATIC_DRAW);
   	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
   	glEnableVertexAttribArray(0);
   	// 第二个设置
   	glBindVertexArray(VAOs[1]);
   	glBindBuffer(GL_ARRAY_BUFFER, VBOs[1]);
   	glBufferData(GL_ARRAY_BUFFER, 9 * sizeof(float), secondPositions, GL_STATIC_DRAW);
   	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
   	glEnableVertexAttribArray(0);
   
   	// 5. 循环函数
   	while (!glfwWindowShouldClose(window))
   	{
   		// 输入
   		processInput(window);
   
   		// 渲染 视口
   		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
   		glClear(GL_COLOR_BUFFER_BIT);
   
   		// 绘制
   		// 第一个
   		glUseProgram(shaderProgramOrange);
   		glBindVertexArray(VAOs[0]);
   		glDrawArrays(GL_TRIANGLES, 0, 3);
   		// 第二个
   		glUseProgram(shaderProgramYellow);
   		glBindVertexArray(VAOs[1]);
   		glDrawArrays(GL_TRIANGLES, 0, 3);
   
   		// 缓冲、更新
   		glfwSwapBuffers(window);
   		glfwPollEvents();
   	}
   
   	glDeleteVertexArrays(2, VAOs);
   	glDeleteBuffers(2, VBOs);
   	glDeleteProgram(shaderProgramOrange);
   	glDeleteProgram(shaderProgramYellow);
   
   	// 6. 结束
   	glfwTerminate();
   
   	return 0;
   }
   
   // 自适应
   void framebuffer_size_callback(GLFWwindow* window, int width, int height)
   {
   	glViewport(0, 0, width, height);
   }
   // 检擦输入
   void processInput(GLFWwindow* window)
   {
   	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
   		glfwSetWindowShouldClose(window, true);
   }
   ~~~

   ![image-20230403101112029](03.OpenGL%20-%20%E5%88%9B%E5%BB%BA%E4%B8%89%E8%A7%92%E5%BD%A2.assets/image-20230403101112029.png)
